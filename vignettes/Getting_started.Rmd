---
title: "Getting started with the artemis package"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting_started}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, echo = FALSE}
library(artemis)
```

The artemis package is designed to aid in the design and data analysis
of eDNA survey studies. These studies are marked by attempting to
detect a species by collecting eDNA shed by that species. The analysis
of these data are confounded by traditional linear regression for the
following reasons:

  1. The eDNA concentration is not directly measured. Instead, the
     eDNA is estimate by the number of quantification cycles of qPCR
     (here after referred to as "Cq" values).
	 
  2. eDNA concentration is related to the Cq values via a calibration
     step, which results in a standard curve for the detections. 
	 
  3. Lower Cq values represent a higher concentration of eDNA in the
     sample. Above a certain threshold, additional cycles are not
     attempted. Therefore, "non-detection" is taken to be any sample
     which requires more than the threshold cycles to detect. 
	 
  4. This data trucation in the observed response increases
     uncertainty in our estimate of the underlying response variable,
     eDNA concentration.
	 
The artemis package resolves these issues by implementing a latent
variable model, which directly models the latent (unobserved) eDNA
concentration, and links this latent variable to the observed response
via the standard curve. Specifically, the artemis package says that
log(eDNA concentration) is a direct response of predictors variables,

$$log(eDNA\ concentration) = X * \beta$$

where $\beta$ is a vector of effects on the log(eDNA concentration).

The eDNA concentration is converted to Cq values via the standard
curve,

$$ \hat{Cq_i} = log(eDNA\ concentration) * \beta_{std\_curve} +
 \alpha_{std\_curve}$$
 
 Any values of $\hat{Cq}$ which are greater than the upper limit on Cq
detections are recorded as the threshold, e.g. a $\hat{Cq}$ value of
42 is recorded as 40 when the upper limit is 40 cycles. 

 Finally, our observed Cq values the $\hat{Cq}$, measured with error,
 
 $$ Cq_i \~ normal(\hat{Cq_i}, \sigma_{Cq}) $$
 
 It is important to note that this model formulation makes some
 assumptions which should be kept in mind:
 
  - log(eDNA concentration) is assumed to be uniform within a sample
  
  - log(eDNA concentration) is sampled without error.
  
  - measurement error is introduced in the qPCR stage. Previous steps
    are assumed to be sampled without error.
	
  - there are no false detections, i.e. the measurement error cannot
    result in a positive detection when eDNA is not present in the
    sample. 
  
*Note: Future versions of the artemis package might allow for measurement
error in both the collection and qPCR stages.*

In artemis, the model is specified using a model formula, similar to
the `lm()` or `lmer()` functions. This model formula is used to
construct the model on log(eDNA concentration).

# Simulations

One of the most basic tasks for the artemis package is simulating
data. Simulated data is useful for testing assumptions, designing a
study, or doing a post-hoc analysis. 

To simulate data, you first must provide a set of levels for each
variable, 

```{r}
vars = list(Intercept = 1,
            distance = c(0, 15, 50),
            volume = c(25, 50),
            tech_rep = 1:10,
            rep = 1:3, Cq = 1)
```

by design, the simulation functions construct a model matrix assuming
a complete block design (i.e. every level is represented). The
variable list provided is expanded using `expand.grid()`. Notice that
we also provided a dummy variable for the response - this is not used
except internally to create the model matrix.

Second, you must provide a set of effect sizes for the variables you
provide. For example, if we were only simulating data using distance,
we might specify the effect sizes as,

```{r}
betas = c(intercept = -10.6, distance = -0.05, volume = 0.1)
```

Please note, these are the effect sizes on the log(eDNA
concentration), not the Cq values. Hence, we specified the intercept
to be -10, or exp(-10) concentration of eDNA. 

To simulate data from a fixed-effects model, we use the
`sim_eDNA_lm()` function,

```{r}
ans = sim_eDNA_lm(Cq ~ distance + volume, vars,
                  betas = c(intercept = -10.6, distance = -0.05, volume = 0.1),
                  sigma_Cq = 1, std_curve_alpha = 21.2, std_curve_beta = -1.5)
```

Notice that we must provide the parameters for the conversion formula
between log(eDNA concentration) and Cq values to the simulation
function, as well as the measurement error on Cq (`sigma_Cq`).

By default, only one instance of simulated data is created, but we can
easily simulate many data sets by adjusting the `n_sim` parameter,
e.g.

```{r eval = FALSE}
ans = sim_eDNA_lm(Cq ~ distance + volume, vars,
                  betas = c(intercept = -10.6, distance = -0.05, volume = 0.1),
                  sigma_Cq = 1, std_curve_alpha = 21.2, std_curve_beta = -1.5,
                  n_sim = 500)

```

If we desire to simulate data where the design is not a complete
block, we can specify our own variable data.frame, `X`, in which case the
variable levels are ignored and the provided data.frame is used to
create a model.matrix.

To simulate for a mixed-effects model, we use the function
`sim_eDNA_lmer()`. Random effects are specified using the syntax of
the lme4 package, e.g. `(1|random effect)`:

```{r}
ans2 = sim_eDNA_lmer(Cq ~ distance + volume + (1|rep) + (1|tech_rep),
                     vars,
                     betas = c(intercept = -10.6, distance = -0.05, volume = 0.01),
                     sigma_Cq = 1,
                     sigma_rand = c(0.1, 0.1),
                     std_curve_alpha = 21.2,
                     std_curve_beta = -1.5)

```

When we are simulating data with random effects, we must provide the
stdev. of the random effects as well as the information for a fixed
effects model. Random effects are generated for these simulations with
the stdev. given. When in cases when mutliple simulations are
performed, different random effects are used for each simulation.

The results of a simulation can be inspected via `summary` and `plot`
methods. This can be helpful in assessing how accurate the simulated
data are, and to test the assumptions behind the model and the betas
used. For example, the results above can be summarized,

```{r}
summary(ans)
```

The default behavior of `summary()` is to give the marginal effects,
i.e. the effects summarized by each level of the variables used to
simulate the data. *WARNING: these marginal effects can be misleading
in cases where interactions are used in the formula.* The summary also
includes a empirical summary of the percent of each level which was
detected, i.e. had a Cq value below the threshold.

**TODO** Plot methods

## Study design

Simulations are helpful for designing new studies. Given a set of
assumptions about the effect sizes, we can simulate how well we are
able to either detect eDNA or how accurately we can estimate those
effects given a number of replications and variable levels in the design.

For example, suppose we wanted to design a study exploring the effects
of different distances on the detection of eDNA. From previous
studies, we have estimated the effect of distance to be -0.04 decrease
in log(eDNA concentration) per meter distance. If we want to have a
sense of how many replicates we need for this study to have at least
80% power (at least 80% chance to estimate the effect of distance
without including 0 in the CI), we can get a quick estimate of this
using the `est_power_lm()` and a given number of reps, say 5 reps. To
do this, we specify the number of replicates in the variable_list as
`1:5`, and specify our effect sizes,

```{r}
dist_power = est_power_lm(Cq ~ 1 + distance,
                          variable_list = list(Cq = 1, distance = c(0,100,300), rep = 1:5),
                          betas = c(intercept = -10.6, distance = -0.04),
                          sigma_Cq = 1, 
                          std_curve_alpha = 21.2, std_curve_beta = -1.5,
                          type = "exclude_zero")

dist_power

```

It appears that 5 replicates was not enough in this case. We could
keep trying different number of replicates until we get the number we
would like. However, it is easier to use the function
`est_power_range_lm`, which will automate this process for us. The
call is similar to the above, but instead of specifying the number of
replicates in the `variable_list`, we provide a `rep_range`, which is
`seq(2,20,2)` (every 2 from 2 to 20) by default

```{r}
dist_power_range = est_power_range_lm(Cq ~ 1 + distance,
                                variable_list = list(Cq = 1, distance = c(0,100,300)),
                                betas = c(intercept = -10.6, distance = -0.04),
                                sigma_Cq = 1, 
                                std_curve_alpha = 21.2, std_curve_beta = -1.5,
                                type = "exclude_zero")

dist_power_range


```

For this study, it looks like we will need greater then 8 replicates
to have our desired 80% power. 

# Modeling

The second purpose of the artemis package is to fit a model to
collected data. Similar to the simulation functions, the artemis
package has two functions which fit a Bayesian latent variable model
to eDNA data; `eDNA_lm()` for fixed effects models and `eDNA_lmer()`
for mixed effects models.

The syntax of these functions is similar to the simulation
functions. We provide a model formula, a data.frame with the observed
data, and then the parameters for standard curve formula to convert
between log(eDNA concentration) and Cq values. For example, to fit a
model to the sample data included in artemis, `eDNA_samples`:

```{r}
model_fit = eDNA_lm(Cq ~ Distance, eDNA_samples,
                    std_curve_alpha = 21.2, std_curve_beta = -1.5)

```

The modeling functions use [Stan](mc-stan.org) to fit the Bayesian
model. Full control of the MCMC algorithm can be accomplished by
passing arguments to `rstan::stan()` in the modeling functions. For
example, 


```{r}
model_fit = eDNA_lm(Cq ~ Distance, eDNA_samples,
                    std_curve_alpha = 21.2, std_curve_beta = -1.5,
                    iter = 1000)

```

By default, artemis suppresses the (often verbose) output from Stan,
but users can (and should) enable it when the model is slow or the
output suggests the MCMC algorithm might not have converged, for
example,

```{r}
model_fit = eDNA_lm(Cq ~ Distance, eDNA_samples,
                    std_curve_alpha = 21.2, std_curve_beta = -1.5,
                    iter = 100,
                    verbose = TRUE)
```

To fit a model with a random effect, users merely use the
`eDNA_lmer()` function and specify the random effects using the syntax
used by lme4,

```{r}
model_fit2 = eDNA_lmer(Cq ~ Distance + Volume + (1|TechnicalRep),
                       eDNA_samples,
                       std_curve_alpha = 21.2, std_curve_beta = -1.5)

```

As with the simulations, the model results can be summarized with
`summary()` and can be plotted with `plot()`,

```{r}
summary(model_fit2)
```

**TODO:** PLOT

## Post-hoc p(detect)

It is common that the purpose of a eDNA sampling study is to inform
the deployment of an automated sampler in the field. For these cases,
we often want to know how likely we are to detect eDNA given the
estimated parameters of the model and a set of conditions. For these
circumstances, we can use the `est_p_detect()` function to see how
well we can detect given effect sizes and conditions,

```{r}
p_detect = est_p_detect(variable_levels = c(Intercept = 1, Distance = 100),
                        betas = c(Intercept = -10.5, Distance = -0.04),
                        Cq_sd = 1, std_curve_alpha = 21.2, std_curve_beta = -1.5,
                        n_rep = 1:12)
```
and we can plot this,

```{r fig = TRUE}
plot(p_detect)

```

Alternatively, we can also use a fit model to estimate the p(detect)
for a set of circumstances. Unlike the above, using a fit model allows
us to estimate the probability of detection with the uncertainty in
our effect size estimates taken into account.

```{r}
p_detect2 = est_p_detect(variable_levels = c(Intercept = 1, Distance = 100),
                        model_fit = model_fit, 
                        Cq_sd = 1, std_curve_alpha = 21.2, std_curve_beta = -1.5,
                        n_rep = 1:12)


```

and we can plot the results,

```{r fig = TRUE}
plot(p_detect2)
```

Notice how we get uncertainty intervals when we use a fit model. 


