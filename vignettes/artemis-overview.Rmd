---
title: "Getting started with the artemis package"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{An overview of the artemis package}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r, include = FALSE, echo = FALSE}
knitr::opts_chunk$set(
  eval = FALSE, # for while editing vignette
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, echo = FALSE, eval=TRUE, message=FALSE, warning=FALSE}
library(artemis)
```

## Background

The `artemis` R package was created to aid in the design and analysis of
environmental DNA (eDNA) survey studies by offering a custom suite of
models for quantitative polymerase chain reaction (qPCR) data from extracted eDNA samples. Data from eDNA sampling surveys is often analyzed with occupancy models or GLMS, but there are
several characteristics of qPCR data in particular which made us feel that it would
benefit from a different modeling approach.  Specifically, our approach to this data makes use of Bayesian truncated latent variable models written in [Stan](mcmc-stan.org).


## Modeling eDNA Data with `artemis`

  1. In eDNA samples that are extracted and run through qPCR analysis, the concentration of eDNA is not directly
     measured. Instead, the amount of eDNA present is represented as a
     function of the number of quantification cycles of qPCR
     (hereafter referred to as the "Cq" value) completed before
     amplification takes place. eDNA concentration ($[eDNA]$) is then
     related to Cq via a standard curve generated in the lab for the
     target species. This standard curve formula typically takes the
     form: $$Cq = log[eDNA] * \beta + \alpha$$ The standard curve is
     specific to the lab reagents and techniques used. The
     implication of this is that models using Cq values (or a derived
     value such as a "positive" detection) as the response result in
     estimates of effect sizes which cannot be directly compared
     between different studies using different standard curves.
	 
  2. A higher Cq value corresponds to a lower concentration of eDNA in
     a sample. Above a pre-determined threshold, additional
     quantification cycles are not attempted. Therefore,
     "non-detection" is taken to be any sample which requires more
     than the threshold number of cycles to detect. Failing to account for this
     data truncation process can result in
     increased uncertainty and bias in our estimates of the effect
     sizes.
  
  3. The potential sources of measurement error in the extraction and
     qPCR processes are difficult to separate and quantify. For
     example, Cq values produced by qPCR become more variable at the
     threshold of detection, i.e. as the number of eDNA molecules
     available for amplification approaches zero.  This source of
     variability in the response is different from that produced by
     error introduced in the pipetting process, but
     they have the same effect on Cq (namely, increasing variability).
	 
The `artemis` package addresses these issues by directly modeling the
effect of the predictors on the latent (unobserved) variable, eDNA
concentration. It does this by linking eDNA concentration to the 
observed response via the parameters of an associated standard curve. The general model is as follows:

$$ Cq_i \sim Normal(\hat{Cq_i}, \sigma_{Cq}) \\
\hat{Cq_i} = \alpha_{std\_curve} + \beta_{std\_curve}* log[eDNA]_i  \\
log[eDNA]_{i} = X_{i} \beta$$ 

<br>

where $\beta$ is a vector of effects on $log[eDNA]$, $X$ is the model
matrix of predictors and
$\alpha_{std\_curve}$ and $\beta_{std\_curve}$ are fixed values
provided by the standard curve.

As detection limits vary with genetic assay, the upper threshold on Cq
in the model is adjustable.  Any values of $\hat{Cq_i}$ which are
greater than the upper limit on $Cq_i$ are recorded as the threshold
value.  For example, a $\hat{Cq_i}$ value of 42 is recorded as 40 when
the upper limit is 40 cycles.
   
   
This model formulation makes several assumptions:
 
  - $log[eDNA]$ is assumed to be uniform within a sample.
  
  - $log[eDNA]$ is sampled without error.
  
  - All measurement error is introduced in the extraction/qPCR
    stage. Field sampling is assumed to take place without error.*
	
  - There are no false detections, i.e. the measurement error cannot
    result in a positive detection when eDNA is not present in the
    sample. 


*`*`Future versions of the `artemis` package might allow for measurement
error in both the field collection and qPCR stages.*

Importantly, this formulation produces estimates of the effect sizes
which:


  - are modeled directly on $log[eDNA]$ rather than Cq, *therefore are independent
	of the standard curve and can be compared between studies*.
  
  - account for the data truncation at the upper limit of qPCR
    cycles, *which reduces uncertainty and bias in the estimates.*
	
  - directly model the measurement error on qPCR extraction, *allowing
    quantification of the amount of uncertainty attributable to
    uncertainty in the effect sizes vs. lab procedure.*

In `artemis`, the model is specified using a model formula, similar to
the `lm()` or `lmer()` functions. This model formula is used to
construct the model on $log[eDNA]$.

The functions in `artemis` generalize to any eDNA survey data containing Cq values associated with a standard curve for the target species.

## Installing `artemis` 

The `artemis` installation guide can be found [here]("https://fishsciences.github.io/artemis/articles/artemis-installation-guide.html").


## A note on included sample data

Since `artemis` was originally written to analyze aquatic eDNA samples, the examples and sample data included in the package (see `?eDNA_data`) reference
variables that are specific to aquatic eDNA survey data. These variables include `volume`
(the the number of mililiters of water that went through the filter in
each sample) and `distance` (the distance in meters from the source of
eDNA).  For example, `eDNA_data` is from a "live car" experiment, where eDNA was sampled at known distances from a source of eDNA (fish in a net pen in unidirectional flow). 

In the following examples, `tech_rep` refers to qPCR replicates generated
 from a single extracted sample or filter; `rep` refers to a single extracted filter or sample.

## Overview of `artemis` Functionality

The functions included in `artemis` can be grouped into a few categories; each category is either introduced in this vignette, or addressed in detail by its own vignette.  [Available vignettes](https://fishsciences.github.io/artemis/articles/) are linked to individually below:

1. [Simulation of data](https://fishsciences.github.io/artemis/articles/simulation.html)
2. [Modeling data](https://fishsciences.github.io/artemis/articles/modeling.html)
3. Conducting post-hoc analyses
      * estimating probability of detection, generating predictions from model fits.
4. Conducting power and precision analyses

These categories are addressed in the sections that follow.    
<br>

The `artemis` package also includes methods for R's `plot()`, `summary()`, `data.frame()`, and `predict()` functions.


## Post-hoc analyses (*p(detect)*)

Often purpose of an eDNA sampling study is to inform a field sampling protocol. For these cases, we often want to know how likely we are to detect eDNA, given the way that we sampled. `est_p_detect()` returns the probability of getting a detection across all planned samples and replicates, where `n_rep` represents the product of the number of filters and technical replicates for each filter.  For example, if you planned to take 2-5 filters at each variable level and then complete 6 extractions for each filter, that would be `n_rep = 12:30`.

```{r eval=TRUE}
p_detect = est_p_detect(variable_levels = c(Intercept = 1, 
                                            Distance = 100),
                        betas = c(Intercept = -10.5, Distance = -0.03),
                        Cq_sd = 1, 
                        std_curve_alpha = 21.2, std_curve_beta = -1.5,
                        n_rep = 12:30)
p_detect
```


We can also plot this,

```{r fig = TRUE, eval=TRUE}
plot(p_detect)

```

Alternatively, we can also use a fit model to estimate the p(detect)
for a set of circumstances. Unlike the above, using a fit model allows
us to estimate the probability of detection with the uncertainty in
our effect size estimates taken into account.

```{r}
p_detect2 = est_p_detect(variable_levels = c(Intercept = 1, 
                                             Distance = 100,
                                             Volume = 50,
                                             DistanceXVolume = 100*50
                                             ),
                        model_fit = model_fit, 
                        n_rep = 1:12)

print(p_detect2)
```

and we can plot the results,

```{r fig = TRUE}
plot(p_detect2, error_width = 0.1)
```

Notice how we get uncertainty intervals when we use a fit model. 

## Predicting outcomes

Once a model is fit, it can be helpful to predict the outcome, either
for the data used to fit the model or new data. For this, `artemis`
provides methods for `predict()` for models fit with `eDNA_lm*()`.  This prediction process is very closely related to simulating data with fixed effect sizes.

## Power and Precision Functions
### Evaluating Simulated Study Designs with the `est_power_*()` functions

Simulations are helpful for designing new studies. Given a set of
assumptions about the effect sizes, we can simulate a full study and evaluate how well we are able to detect eDNA, and/or or whether the proposed design allows us to estimate those effects with precision.

For example, suppose we wanted to design a study exploring the effects
of different distances on the detection of eDNA. From previous
studies, we have estimated the effect of distance to be a -0.04 decrease
in log[eDNA] per meter distance away from source. If we want to have a
sense of how many replicates we need for this study to have at least
80% power (>=80% chance of estimating a beta for distance
without including 0 in its CI), we can do this using the `est_power_lm()` and specifying a design. To do this, we specify the number of replicate filters as a vector (`rep`) in the `variable_list`, along with the rest of our variables and argument values.  *Note that these functions are not yet parallelized and may take some time to run on your machine*

```{r warning = FALSE}
dist_power = est_power_lm(Cq ~ 1 + distance,
                          variable_list = list(Cq = 1, 
                                               distance = c(0,100,300), 
                                               rep = 1:3),
                          betas = c(intercept = -10.6, distance = -0.04),
                          sigma_Cq = 1, 
                          std_curve_alpha = 21.2, std_curve_beta = -1.5,
                          type = "exclude_zero")

dist_power

```

It appears that 3 samples was not enough to estimate the effect of distance in this case. We could keep trying different number of replicates until we get the number we
would like. However, it is easier to use the function
`est_power_range_lm()`, which will automate this process for us. The
call is similar to the one above, but instead of specifying the number of
replicates in the `variable_list`, we provide a `rep_range`, which is
`seq(2,20,2)` (every 2 from 2 to 20) by default. It will stop running once the specified power level is reached.  Warning, this is
quite CPU intensive, so for this demonstation, we will be lowering the
`rep_range` and the number of iterations for each case:

```{r warning = FALSE}
set.seed(1234)
dist_power_range = est_power_range_lm(Cq ~ 1 + distance,
                                variable_list = list(Cq = 1, 
                                                     distance = c(0,100,300)),
                                betas = c(intercept = -10.6, distance = -0.04),
                                sigma_Cq = 1, 
                                std_curve_alpha = 21.2, std_curve_beta = -1.5,
                                type = "exclude_zero",
                                rep_range = c(5,10))

dist_power_range

#> $`n_rep: 5`
#> (Intercept)    distance 
#>           1           0 
#> 
#> $`n_rep: 10`
#> (Intercept)    distance 
#>           1           1 
```

For this study, it looks like we will need greater then 5 replicates (but perhaps less than 10) to have our desired 80% power. 

<br>
<br>
---
<br>
<br>
